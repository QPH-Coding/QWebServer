# 开发者日志

## 日志

## 2022.10.08

- 17:19:50: 现在已经基本完成了

之后的安排:

- 处理一些信号，如SIGPIPE信号

## 2022.10.07

- 15:34:16: 现在服务器支持HTTP请求头中的`Range`字段，并且能够正常播放视频

## 2022.10.06

- 15:31:10: 完成了一些HTML页面，并且能够显示图片

## 2022.10.05

- 18:38:58: 完成一些HTML页面。完成一些MySql的操作。加入了配置文件的读取。

- 23:55:43: 完成了MySql的相关接口，现在可以插入用户并且检验密码是否正确。

之后的安排:

- 和昨天一样

## 2022.10.04

- 16:06:40: 改变了开发环境，现在在VM虚拟机上开发，并且已经能够使用mysql++连接到MySql。并且我发现我忽略了两件事，一个是我必须写一些响应头，另一个是我必须处理一些信号。

- 22:50:27: 完成对象池并且可以使用MySql的连接器SDK-mysql++。现在可以自动添加 `content-type` 和`content-length` 两个响应头。

之后的安排:

- 设计user表

- 完成HTTP接口

- 写一些HTML页面

## 2022.10.03

- 11:31:41: Reconstruct the AsyncLog4Q, use `#define` can log the source file and the code line.

- 14:23:08: Now the server can response a simple index.html.

The day after:

- Read `Config` from `/server/config/config.json`

- Object Pool

- Connect to MySql

- Finish Http Implements

## 2022.10.02

- 09:41:02: 成功重构代码，我放弃了使用自己封装`Threa`类，并且转而使用`std::thread`(C++11)。

- 16:21:23: 完成HTTP请求 `HttpRequest` 的解析和 构造`HttpResponse`.

之后的安排:

- 加入一些HTTP接口可以响应一些请求

- 在日志中加入记录源文件及代码行号

## 2022.10.01

- 13:55:20: 完成时间轮，但是没法直接进行测试。

- 16:30:42: 修复了`Timer`计时器的bug，现在它可以正确的重置计时。

## 2022.09.30

- 23:58:03: 完成异步日志系统。在开发过程中，我发现必须创建两个线程用于管理他们自身的计时器，还需要一个线程去专门写日志到文件里面

之后的安排:

- 可能可以优化一下异步日志系统，加入记录源文件及代码

- 时间轮

- HTTP连接

- 对象池

## 2022.09.29

- 11:17:11: 我学习到了一个更好的事件处理模型-多Reactor模型，这个模型需要两个线程池，一个是`sub-Reactor` 负责I/O操作，另一个是`logic-operating`逻辑处理单元，用于处理HTTP请求。所以我认为我应该降低线程池的耦合性，重新设计一下。
  coupling of the thread pool, redesign it.
  
- 15:23:49: 我已经完成了对线程池的重新设计，现在线程池是有高可复用性的。

- 20:59:04: 完成计时器，使用timerfd系列函数及epoll

之后的安排:

- 时间轮

- 异步日志系统-`AsyncLog4Q` 及缓冲区

- HTTP连接-解析HTTP请求并且制作响应

- 对象池-可以试试参考工厂模式

## 2022.09.28

- 11:50:00: 线程池能够正常工作，在debug和测试的时候，我发现一个线程安全的日志系统是十分重要的。如果我是用`std::cout` 或者`printf`，线程会竞争地想输出流写入，导致debug的一些输出是没法看的 。
  
- 15:54:56: 在仔细的阅读了陈硕的书后，我认为为了开发出一个异步日志系统，我需要先开发出以下组件或模块：
    - 缓冲区

    - 计时器

    - 文件I/O管理

未来的安排:

- 文件I/O: 设计些处理文件I/O的API，可以给日志系统使用

- 缓冲区: 为了日志系统

- 计时器: 使用 `timer_fd`系列函数和 `epoll`(使用自己封装的`EpollListener`) 去设计一个计时器

- 时间戳: 一个可以正确管理时间的组件

- 日志系统: 日志系统由以下部分组成: 缓冲区，计时器，并且有固定格式能够用正则去解析

### 2022.09.27

总结: 今天先完成了线程池。但是没法通过单元测试，我不能解决一些未知的bug。它让程序只创建出一个线程并且在原地阻塞

未来安排:

- `Thread`: 重写 `class Thread`，使其像Java的线程一项，可以通过继承基类Thread去使用。不要去使用 `std::function<void ()>`，这造成了很多麻烦。
  
- `Thread Pool`: 重新设计它，我想要它变成一个高可用的线程。但是现在出现了一些超过我能力范围外的错误。所以我在想在这个项目中，线程池可能只会使用一次，所以可能这点的优先级可以不用那么高。

## Bug修复

- Question: 模版元编程时，出现未定义xxx的错误

  Solution: 当使用模版元编程时，应该讲函数的声明和定义放在同一个文件中

- Question: 异步日志系统不能正确地使用计时器

  Solution: 额外使用两个线程独立的管理计时器

- Question: 异步日志系统不能正确地创建线程

  Solution: 不能用`Join()`，必须用`Detach()`，让线程自己运转

- Question: `fwrite()` 不能写入文件

  Solution: 必须在代码中插入 `fseek()`，插入它以后正常运行

- Question: `Timer` 计时器不能正确的重置计时

  Solution: 我简单地用`stop()` 和 `start()`去重置计时，但是不起效果。在阅读完 `timerfd_settime()`的相关文档后，我发现我可以用这个函数去重置计时器而不是用 `Stop()` 和 `Start()`。并且现在我感觉计时器的成员函数名字 `Exit()`比`Stop()`更合适。
  
- Question: 不能通过HTTP发送图片，浏览器显示的报错为`ERR_CONTENT_LENGTH_MISMATCH`(内容长度不符)

  Solution: 一开始，我以为出现这个问题的原因是我去写socket的方法不对。但是在修改和观察后发现，这和它没有关系。最后，我发现图片资源可以被读入为`char`，但是这不意味着它可以被转型为`std::string`。所以我讲HTTP响应的头部和实体分开，使用 `std::vector<char>` 去存储图片的数据

- Question: 在重构完代码后，不能够传输视频

  Solution: 实际上这个问题是不能够传输大的文件。因为epoll监听写事件`EPOLLOUT`失败了。因为我没有完全明白epoll的事件管理。当某个文件描述符的某事件已经被epoll监听，即epoll中已经存在了这个文件描述符fd时，再去添加这个文件描述符是不行的，应该去修改它所绑定的事件。